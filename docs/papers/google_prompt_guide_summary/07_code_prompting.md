ë„¤, 07ë²ˆ íŒŒì¼ì˜ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ì„ í™•ì¸í•˜ê³  ìˆ˜ì •í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤. ë‚´ìš©ì€ ë™ì¼í•˜ê²Œ ìœ ì§€í•˜ë©´ì„œ í˜•ì‹ë§Œ ì •ë¦¬í•˜ê² ìŠµë‹ˆë‹¤.

# ğŸ“˜ 07. ì½”ë“œ í”„ë¡¬í”„íŒ… (Code Prompting)

## í•µì‹¬ ìš”ì•½
- **ì½”ë“œ ì‘ì„± í”„ë¡¬í”„íŒ…**ì€ ê°œë°œìì˜ ì½”ë”© ì†ë„ë¥¼ í–¥ìƒì‹œí‚¤ê³  ë°˜ë³µ ì‘ì—…ì„ ìë™í™”í•˜ëŠ” ê°•ë ¥í•œ ë„êµ¬
- **ì½”ë“œ ì„¤ëª… í”„ë¡¬í”„íŒ…**ì€ ë‹¤ë¥¸ ê°œë°œìì˜ ì½”ë“œë¥¼ ì´í•´í•˜ê±°ë‚˜ ë³µì¡í•œ ë¡œì§ì„ ë¬¸ì„œí™”í•  ë•Œ ìœ ìš©
- **ì½”ë“œ ë²ˆì—­ í”„ë¡¬í”„íŒ…**ì€ í•œ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì—ì„œ ë‹¤ë¥¸ ì–¸ì–´ë¡œ ì½”ë“œë¥¼ ë³€í™˜í•˜ì—¬ ì¬ì‚¬ìš©ì„±ì„ ë†’ì„
- **ë””ë²„ê¹… ë° ë¦¬ë·° í”„ë¡¬í”„íŒ…**ì€ ì½”ë“œì˜ ì˜¤ë¥˜ë¥¼ ì°¾ê³  ê°œì„ ì ì„ ì œì•ˆí•˜ì—¬ ì½”ë“œ í’ˆì§ˆì„ í–¥ìƒì‹œí‚´
- **ë‚®ì€ Temperature (0.1-0.3)** ì„¤ì •ì´ ì½”ë“œ ìƒì„±ì—ì„œ ì •í™•ì„±ê³¼ ì¼ê´€ì„±ì„ ë³´ì¥í•˜ëŠ” ë° ì¤‘ìš”

## ì£¼ìš” ê°œë…ê³¼ ì„¤ëª…

### ğŸ’» **ì½”ë“œ ì‘ì„± í”„ë¡¬í”„íŒ… (Code Writing Prompts)**
- **ëª©ì **: íŠ¹ì • ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ì½”ë“œë¥¼ ìë™ìœ¼ë¡œ ìƒì„±
- **ì¥ì **: ê°œë°œ ì‹œê°„ ë‹¨ì¶•, ë°˜ë³µ ì‘ì—… ìë™í™”, ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œ ìƒì„±
- **ì ìš© ë¶„ì•¼**: ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±, í•¨ìˆ˜ êµ¬í˜„, ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„, ë°ì´í„° ì²˜ë¦¬ ì½”ë“œ
- **ì£¼ì˜ì‚¬í•­**: ìƒì„±ëœ ì½”ë“œëŠ” ë°˜ë“œì‹œ ê²€í†  ë° í…ŒìŠ¤íŠ¸ í•„ìš”

### ğŸ“– **ì½”ë“œ ì„¤ëª… í”„ë¡¬í”„íŒ… (Code Explanation Prompts)**
- **ëª©ì **: ê¸°ì¡´ ì½”ë“œì˜ ë™ì‘ ì›ë¦¬ì™€ êµ¬ì¡°ë¥¼ ì´í•´í•˜ê¸° ì‰½ê²Œ ì„¤ëª…
- **í™œìš©**: ì½”ë“œ ë¦¬ë·°, ë¬¸ì„œí™”, í•™ìŠµ, ìœ ì§€ë³´ìˆ˜
- **íŠ¹ì§•**: ë‹¨ê³„ë³„ ë¶„ì„, í•¨ìˆ˜ë³„ ì„¤ëª…, ì•Œê³ ë¦¬ì¦˜ ë¡œì§ í•´ì„

### ğŸ”„ **ì½”ë“œ ë²ˆì—­ í”„ë¡¬í”„íŒ… (Code Translation Prompts)**
- **ëª©ì **: í•œ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë¡œ ì‘ì„±ëœ ì½”ë“œë¥¼ ë‹¤ë¥¸ ì–¸ì–´ë¡œ ë³€í™˜
- **í™œìš©**: ë ˆê±°ì‹œ ì‹œìŠ¤í…œ ë§ˆì´ê·¸ë ˆì´ì…˜, ë‹¤ì¤‘ í”Œë«í¼ ì§€ì›, í”„ë¡œí† íƒ€ì´í•‘
- **ì£¼ì˜ì **: ì–¸ì–´ë³„ íŠ¹ì„±ê³¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì°¨ì´ ê³ ë ¤ í•„ìš”

### ğŸ› **ë””ë²„ê¹… ë° ë¦¬ë·° í”„ë¡¬í”„íŒ… (Debugging & Review Prompts)**
- **ëª©ì **: ì½”ë“œì˜ ì˜¤ë¥˜ ë°œê²¬, ì„±ëŠ¥ ê°œì„ ì  ì œì•ˆ, ì½”ë“œ í’ˆì§ˆ í–¥ìƒ
- **ê¸°ëŠ¥**: ì˜¤ë¥˜ ì›ì¸ ë¶„ì„, ìˆ˜ì • ë°©ë²• ì œì‹œ, ìµœì í™” ì œì•ˆ, ë³´ì•ˆ ì·¨ì•½ì  ê²€í† 

## í”„ë¡¬í”„íŠ¸ ì˜ˆì‹œ

### ì½”ë“œ ì‘ì„± - Bash ìŠ¤í¬ë¦½íŠ¸
```plaintext
# ì‘ì—… ì„¤ëª…
í´ë” ë‚´ ëª¨ë“  íŒŒì¼ì˜ ì´ë¦„ì„ ë³€ê²½í•˜ëŠ” Bash ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.

ìš”êµ¬ì‚¬í•­:
- ì‚¬ìš©ìë¡œë¶€í„° í´ë”ëª… ì…ë ¥ë°›ê¸°
- ê° íŒŒì¼ ì´ë¦„ ì•ì— "draft_" ì ‘ë‘ì–´ ì¶”ê°€
- í´ë” ì¡´ì¬ ì—¬ë¶€ í™•ì¸
- ì˜¤ë¥˜ ì²˜ë¦¬ í¬í•¨

Bash ì½”ë“œ:
```

**ì¶œë ¥**:
```bash
#!/bin/bash

# í´ë”ëª… ì…ë ¥ë°›ê¸°
echo "Enter the folder name: "
read folder_name

# í´ë” ì¡´ì¬ ì—¬ë¶€ í™•ì¸
if [ ! -d "$folder_name" ]; then
    echo "Folder does not exist."
    exit 1
fi

# í´ë” ë‚´ íŒŒì¼ë“¤ ê°€ì ¸ì˜¤ê¸°
files=( "$folder_name"/* )

# ê° íŒŒì¼ ì´ë¦„ ë³€ê²½
for file in "${files[@]}"; do
    if [ -f "$file" ]; then
        new_file_name="$folder_name/draft_$(basename "$file")"
        mv "$file" "$new_file_name"
        echo "Renamed: $(basename "$file") â†’ draft_$(basename "$file")"
    fi
done

echo "Files renamed successfully."
```

### ì½”ë“œ ì„¤ëª… - Python í•¨ìˆ˜ ë¶„ì„
```plaintext
# ì½”ë“œ ì„¤ëª… ìš”ì²­
ë‹¤ìŒ Python ì½”ë“œê°€ ì–´ë–¤ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ”ì§€ ë‹¨ê³„ë³„ë¡œ ì„¤ëª…í•´ì£¼ì„¸ìš”:

import os
import shutil

def organize_files_by_extension(source_folder):
    for filename in os.listdir(source_folder):
        if os.path.isfile(os.path.join(source_folder, filename)):
            file_extension = os.path.splitext(filename)[1:]
            
            if file_extension:
                target_folder = os.path.join(source_folder, file_extension)
                
                if not os.path.exists(target_folder):
                    os.makedirs(target_folder)
                
                shutil.move(
                    os.path.join(source_folder, filename),
                    os.path.join(target_folder, filename)
                )

ì„¤ëª…:
```

**ì¶œë ¥**:
ì´ Python í•¨ìˆ˜ëŠ” **íŒŒì¼ í™•ì¥ìë³„ ìë™ ì •ë¦¬** ê¸°ëŠ¥ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤:

**1ë‹¨ê³„: í´ë” íƒìƒ‰**
- `os.listdir(source_folder)`ë¡œ ì§€ì •ëœ í´ë”ì˜ ëª¨ë“  í•­ëª©ì„ ê°€ì ¸ì˜µë‹ˆë‹¤

**2ë‹¨ê³„: íŒŒì¼ í•„í„°ë§** 
- `os.path.isfile()`ë¡œ í´ë”ê°€ ì•„ë‹Œ íŒŒì¼ë§Œ ì„ ë³„í•©ë‹ˆë‹¤

**3ë‹¨ê³„: í™•ì¥ì ì¶”ì¶œ**
- `os.path.splitext(filename)[1:]`ë¡œ íŒŒì¼ í™•ì¥ìë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤
- ì˜ˆ: "document.pdf" â†’ "pdf"

**4ë‹¨ê³„: ëŒ€ìƒ í´ë” ìƒì„±**
- í™•ì¥ìëª…ê³¼ ë™ì¼í•œ ì´ë¦„ì˜ í•˜ìœ„ í´ë”ë¥¼ ìƒì„±í•©ë‹ˆë‹¤
- `os.makedirs()`ë¡œ í´ë”ê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ë§Œë“­ë‹ˆë‹¤

**5ë‹¨ê³„: íŒŒì¼ ì´ë™**
- `shutil.move()`ë¡œ íŒŒì¼ì„ í•´ë‹¹ í™•ì¥ì í´ë”ë¡œ ì´ë™í•©ë‹ˆë‹¤

**ê²°ê³¼**: ê°™ì€ í™•ì¥ìì˜ íŒŒì¼ë“¤ì´ ê°ê°ì˜ í´ë”ë¡œ ìë™ ë¶„ë¥˜ë©ë‹ˆë‹¤

### ì½”ë“œ ë²ˆì—­ - Bash to Python
```plaintext
# ì½”ë“œ ë²ˆì—­ ìš”ì²­
ë‹¤ìŒ Bash ìŠ¤í¬ë¦½íŠ¸ë¥¼ Pythonìœ¼ë¡œ ë²ˆì—­í•´ì£¼ì„¸ìš”:

#!/bin/bash
echo "Enter the folder name: "
read folder_name

if [ ! -d "$folder_name" ]; then
    echo "Folder does not exist."
    exit 1
fi

files=( "$folder_name"/* )
for file in "${files[@]}"; do
    new_file_name="draft_$(basename "$file")"
    mv "$file" "$new_file_name"
done
echo "Files renamed successfully."

Python ì½”ë“œ:
```

**ì¶œë ¥**:
```python
import os
import shutil

def rename_files_with_prefix():
    # í´ë”ëª… ì…ë ¥ë°›ê¸°
    folder_name = input("Enter the folder name: ")
    
    # í´ë” ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    if not os.path.isdir(folder_name):
        print("Folder does not exist.")
        return
    
    # í´ë” ë‚´ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    try:
        files = os.listdir(folder_name)
        
        # ê° íŒŒì¼ ì´ë¦„ ë³€ê²½
        for file in files:
            old_path = os.path.join(folder_name, file)
            
            # íŒŒì¼ì¸ì§€ í™•ì¸ (í´ë” ì œì™¸)
            if os.path.isfile(old_path):
                new_filename = f"draft_{file}"
                new_path = os.path.join(folder_name, new_filename)
                
                shutil.move(old_path, new_path)
                print(f"Renamed: {file} â†’ {new_filename}")
        
        print("Files renamed successfully.")
        
    except Exception as e:
        print(f"An error occurred: {e}")

# í•¨ìˆ˜ ì‹¤í–‰
if __name__ == "__main__":
    rename_files_with_prefix()
```

### ë””ë²„ê¹… - ì˜¤ë¥˜ ìˆ˜ì •
```plaintext
# ë””ë²„ê¹… ìš”ì²­
ë‹¤ìŒ Python ì½”ë“œì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤. ë¬¸ì œì ì„ ì°¾ê³  ìˆ˜ì •ëœ ì½”ë“œë¥¼ ì œê³µí•´ì£¼ì„¸ìš”:

ì˜¤ë¥˜ ë©”ì‹œì§€:
NameError: name 'toUpperCase' is not defined

ë¬¸ì œ ì½”ë“œ:
import os
import shutil

folder_name = input("Enter the folder name: ")
prefix = input("Enter the prefix: ")
text = toUpperCase(prefix)  # ì˜¤ë¥˜ ë°œìƒ ì§€ì 

if not os.path.isdir(folder_name):
    print("Folder does not exist.")
    exit(1)

files = os.listdir(folder_name)
for file in files:
    new_filename = f"{text}_{file}"
    shutil.move(
        os.path.join(folder_name, file), 
        os.path.join(folder_name, new_file_name)  # ë³€ìˆ˜ëª… ë¶ˆì¼ì¹˜
    )

ë¶„ì„ ë° ìˆ˜ì •:
```

**ì¶œë ¥**:
## ğŸ› ë¬¸ì œì  ë¶„ì„

**1. í•¨ìˆ˜ëª… ì˜¤ë¥˜**: `toUpperCase()`ëŠ” ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤
- **í•´ê²°**: Pythonì˜ ë‚´ì¥ ë©”ì„œë“œ `upper()` ì‚¬ìš©

**2. ë³€ìˆ˜ëª… ë¶ˆì¼ì¹˜**: `new_filename`ìœ¼ë¡œ ì •ì˜í–ˆìœ¼ë‚˜ `new_file_name`ìœ¼ë¡œ ì‚¬ìš©
- **í•´ê²°**: ë³€ìˆ˜ëª… í†µì¼

## âœ… ìˆ˜ì •ëœ ì½”ë“œ

```python
import os
import shutil

def rename_files_with_prefix():
    folder_name = input("Enter the folder name: ")
    prefix = input("Enter the prefix: ")
    
    # ì˜¬ë°”ë¥¸ ëŒ€ë¬¸ì ë³€í™˜ ë©”ì„œë“œ ì‚¬ìš©
    text = prefix.upper()
    
    if not os.path.isdir(folder_name):
        print("Folder does not exist.")
        return
    
    try:
        files = os.listdir(folder_name)
        
        for file in files:
            if os.path.isfile(os.path.join(folder_name, file)):
                # ë³€ìˆ˜ëª… í†µì¼
                new_filename = f"{text}_{file}"
                
                old_path = os.path.join(folder_name, file)
                new_path = os.path.join(folder_name, new_filename)
                
                shutil.move(old_path, new_path)
                print(f"Renamed: {file} â†’ {new_filename}")
        
        print("Files renamed successfully.")
        
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    rename_files_with_prefix()
```

## ğŸ’¡ ì¶”ê°€ ê°œì„  ì‚¬í•­

1. **ì˜¤ë¥˜ ì²˜ë¦¬ ê°•í™”**: try-except ë¸”ë¡ ì¶”ê°€
2. **íŒŒì¼ í•„í„°ë§**: ë””ë ‰í„°ë¦¬ ì œì™¸í•˜ê³  íŒŒì¼ë§Œ ì²˜ë¦¬
3. **í•¨ìˆ˜í™”**: ì¬ì‚¬ìš© ê°€ëŠ¥í•œ í•¨ìˆ˜ë¡œ êµ¬ì¡°í™”
4. **ì‚¬ìš©ì í”¼ë“œë°±**: ê° íŒŒì¼ ì²˜ë¦¬ ìƒí™© ì¶œë ¥

## í™œìš© íŒ

### ğŸš€ **LangChainì—ì„œì˜ ì½”ë“œ ìƒì„± ì²´ì¸**
```python
from langchain.prompts import PromptTemplate
from langchain.llms import VertexAI
from langchain.chains import LLMChain

# ì½”ë“œ ìƒì„± í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿
code_generation_template = """
ì‘ì—…: {task}
í”„ë¡œê·¸ë˜ë° ì–¸ì–´: {language}
ìš”êµ¬ì‚¬í•­:
{requirements}

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì½”ë“œë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”:
1. ì½”ë“œ ì„¤ëª… (ì£¼ì„ í¬í•¨)
2. ì™„ì „í•œ ì‹¤í–‰ ê°€ëŠ¥í•œ ì½”ë“œ
3. ì‚¬ìš© ì˜ˆì‹œ

ì½”ë“œ:
"""

code_prompt = PromptTemplate(
    input_variables=["task", "language", "requirements"],
    template=code_generation_template
)

# ë‚®ì€ temperatureë¡œ ì •í™•í•œ ì½”ë“œ ìƒì„±
llm = VertexAI(
    model_name="gemini-pro",
    temperature=0.1,  # ì½”ë“œ ìƒì„±ì‹œ ì •í™•ì„± ìš°ì„ 
    max_output_tokens=2048
)

code_chain = LLMChain(llm=llm, prompt=code_prompt)

# ì‚¬ìš© ì˜ˆì‹œ
result = code_chain.run(
    task="CSV íŒŒì¼ì„ ì½ì–´ì„œ ë°ì´í„° ë¶„ì„í•˜ëŠ” ìŠ¤í¬ë¦½íŠ¸",
    language="Python",
    requirements="""
    - pandas ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
    - ê¸°ë³¸ í†µê³„ ì •ë³´ ì¶œë ¥
    - ì‹œê°í™” í¬í•¨ (matplotlib)
    - ì˜¤ë¥˜ ì²˜ë¦¬ í¬í•¨
    """
)
```

### ğŸ”§ **ì½”ë“œ ë¦¬ë·° ìë™í™” ì²´ì¸**
```python
class CodeReviewChain:
    def __init__(self, llm):
        self.llm = llm
        self.review_template = """
ë‹¤ìŒ {language} ì½”ë“œë¥¼ ë¦¬ë·°í•˜ê³  ê°œì„ ì ì„ ì œì•ˆí•´ì£¼ì„¸ìš”:

```
{code}
```

ë‹¤ìŒ ê´€ì ì—ì„œ ë¶„ì„í•´ì£¼ì„¸ìš”:
1. ì½”ë“œ í’ˆì§ˆ ë° ê°€ë…ì„±
2. ì„±ëŠ¥ ìµœì í™” ê°€ëŠ¥ì„±
3. ë³´ì•ˆ ì·¨ì•½ì 
4. ì˜¤ë¥˜ ì²˜ë¦¬
5. ì½”ë”© ì»¨ë²¤ì…˜ ì¤€ìˆ˜

ë¦¬ë·° ê²°ê³¼:
- ì „ì²´ í‰ê°€: [1-10ì ]
- ì£¼ìš” ë¬¸ì œì : 
- ê°œì„  ì œì•ˆ:
- ìˆ˜ì •ëœ ì½”ë“œ (í•„ìš”ì‹œ):
"""
    
    def review_code(self, code: str, language: str = "python") -> str:
        """ì½”ë“œ ë¦¬ë·° ìˆ˜í–‰"""
        prompt = self.review_template.format(
            code=code,
            language=language
        )
        
        response = self.llm.predict(prompt)
        return response
    
    def explain_code(self, code: str, language: str = "python") -> str:
        """ì½”ë“œ ì„¤ëª… ìƒì„±"""
        explain_prompt = f"""
ë‹¤ìŒ {language} ì½”ë“œì˜ ë™ì‘ì„ ì´ˆë³´ìë„ ì´í•´í•  ìˆ˜ ìˆê²Œ ë‹¨ê³„ë³„ë¡œ ì„¤ëª…í•´ì£¼ì„¸ìš”:

```
{code}
```

ì„¤ëª…:
1. ì „ì²´ ëª©ì :
2. ì£¼ìš” êµ¬ì„± ìš”ì†Œ:
3. ë‹¨ê³„ë³„ ë™ì‘:
4. ì‚¬ìš©ëœ ê¸°ìˆ /ë¼ì´ë¸ŒëŸ¬ë¦¬:
"""
        
        return self.llm.predict(explain_prompt)

# ì‚¬ìš© ì˜ˆì‹œ
llm = VertexAI(model_name="gemini-pro", temperature=0.2)
reviewer = CodeReviewChain(llm)

sample_code = """
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)
"""

review_result = reviewer.review_code(sample_code, "python")
explanation = reviewer.explain_code(sample_code, "python")
```

### ğŸ¯ **ë‹¤ì¤‘ ì–¸ì–´ ì½”ë“œ ë²ˆì—­ê¸°**
```python
class CodeTranslator:
    def __init__(self, llm):
        self.llm = llm
        
    def translate_code(self, source_code: str, from_lang: str, to_lang: str, 
                      include_comments: bool = True) -> str:
        """ì½”ë“œë¥¼ ë‹¤ë¥¸ ì–¸ì–´ë¡œ ë²ˆì—­"""
        
        comment_instruction = "ì£¼ì„ê³¼ ì„¤ëª…ë„ í•¨ê»˜ í¬í•¨í•´ì£¼ì„¸ìš”." if include_comments else ""
        
        translate_prompt = f"""
ë‹¤ìŒ {from_lang} ì½”ë“œë¥¼ {to_lang}ìœ¼ë¡œ ë²ˆì—­í•´ì£¼ì„¸ìš”.

ì›ë³¸ ì½”ë“œ:
```
{source_code}
```

ë²ˆì—­ ìš”êµ¬ì‚¬í•­:
- ë™ì¼í•œ ê¸°ëŠ¥ êµ¬í˜„
- {to_lang}ì˜ ê´€ë¡€ì™€ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ ì ìš©
- í•„ìš”í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ import í¬í•¨
{comment_instruction}

ë²ˆì—­ëœ {to_lang} ì½”ë“œ:
"""
        
        return self.llm.predict(translate_prompt)
    
    def batch_translate(self, code_snippets: list, from_lang: str, to_lang: str) -> list:
        """ì—¬ëŸ¬ ì½”ë“œ ìŠ¤ë‹ˆí« ì¼ê´„ ë²ˆì—­"""
        results = []
        
        for i, code in enumerate(code_snippets):
            print(f"ë²ˆì—­ ì¤‘... ({i+1}/{len(code_snippets)})")
            translated = self.translate_code(code, from_lang, to_lang)
            results.append({
                'original': code,
                'translated': translated,
                'from': from_lang,
                'to': to_lang
            })
        
        return results

# ì‚¬ìš© ì˜ˆì‹œ
translator = CodeTranslator(llm)

bash_script = """
#!/bin/bash
for file in *.txt; do
    echo "Processing $file"
    wc -l "$file"
done
"""

python_version = translator.translate_code(bash_script, "bash", "python")
print(python_version)
```

### ğŸ› **ìŠ¤ë§ˆíŠ¸ ë””ë²„ê±°**
```python
class SmartDebugger:
    def __init__(self, llm):
        self.llm = llm
    
    def debug_error(self, code: str, error_message: str, language: str = "python") -> dict:
        """ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì½”ë“œ ë””ë²„ê¹…"""
        
        debug_prompt = f"""
ë‹¤ìŒ {language} ì½”ë“œì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:

ì˜¤ë¥˜ ë©”ì‹œì§€:
```
{error_message}
```

ì½”ë“œ:
```
{code}
```

ë‹¤ìŒì„ ë¶„ì„í•´ì£¼ì„¸ìš”:
1. ì˜¤ë¥˜ ì›ì¸ ë¶„ì„
2. êµ¬ì²´ì ì¸ ìˆ˜ì • ë°©ë²•
3. ìˆ˜ì •ëœ ì½”ë“œ
4. ì˜ˆë°© ë°©ë²•
5. ê´€ë ¨ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

ë¶„ì„ ê²°ê³¼:
"""
        
        response = self.llm.predict(debug_prompt)
        
        # êµ¬ì¡°í™”ëœ ê²°ê³¼ ë°˜í™˜
        return {
            'original_code': code,
            'error_message': error_message,
            'analysis': response,
            'language': language
        }
    
    def optimize_code(self, code: str, language: str = "python") -> str:
        """ì½”ë“œ ì„±ëŠ¥ ìµœì í™” ì œì•ˆ"""
        
        optimize_prompt = f"""
ë‹¤ìŒ {language} ì½”ë“œì˜ ì„±ëŠ¥ì„ ê°œì„ í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ì œì•ˆí•´ì£¼ì„¸ìš”:

```
{code}
```

ë¶„ì„í•  ì˜ì—­:
- ì‹œê°„ ë³µì¡ë„ ê°œì„ 
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”
- ê°€ë…ì„± í–¥ìƒ
- ì—ëŸ¬ ì²˜ë¦¬ ê°•í™”

ìµœì í™” ì œì•ˆ:
"""
        
        return self.llm.predict(optimize_prompt)
    
    def security_audit(self, code: str, language: str = "python") -> str:
        """ë³´ì•ˆ ì·¨ì•½ì  ê²€ì‚¬"""
        
        security_prompt = f"""
ë‹¤ìŒ {language} ì½”ë“œì˜ ë³´ì•ˆ ì·¨ì•½ì ì„ ê²€ì‚¬í•´ì£¼ì„¸ìš”:

```
{code}
```

ê²€ì‚¬ í•­ëª©:
- ì…ë ¥ ê²€ì¦
- SQL ì¸ì ì…˜ ê°€ëŠ¥ì„±
- XSS ì·¨ì•½ì 
- íŒŒì¼ ì‹œìŠ¤í…œ ì ‘ê·¼ ë³´ì•ˆ
- ê¶Œí•œ ê´€ë¦¬
- ë°ì´í„° ë…¸ì¶œ ìœ„í—˜

ë³´ì•ˆ ë¶„ì„ ê²°ê³¼:
"""
        
        return self.llm.predict(security_prompt)

# ì‚¬ìš© ì˜ˆì‹œ
debugger = SmartDebugger(llm)

# ì˜¤ë¥˜ ì½”ë“œ ì˜ˆì‹œ
buggy_code = """
def divide_numbers(a, b):
    return a / b

result = divide_numbers(10, 0)
print(result)
"""

error_msg = "ZeroDivisionError: division by zero"

debug_result = debugger.debug_error(buggy_code, error_msg)
optimization = debugger.optimize_code(buggy_code)
security_audit = debugger.security_audit(buggy_code)
```

### ğŸ“Š **ì½”ë“œ í’ˆì§ˆ ë©”íŠ¸ë¦­ ë¶„ì„ê¸°**
```python
class CodeQualityAnalyzer:
    def __init__(self, llm):
        self.llm = llm
    
    def analyze_quality(self, code: str, language: str = "python") -> dict:
        """ì¢…í•©ì ì¸ ì½”ë“œ í’ˆì§ˆ ë¶„ì„"""
        
        quality_prompt = f"""
ë‹¤ìŒ {language} ì½”ë“œì˜ í’ˆì§ˆì„ ì¢…í•©ì ìœ¼ë¡œ ë¶„ì„í•´ì£¼ì„¸ìš”:

```
{code}
```

í‰ê°€ ê¸°ì¤€ (ê° í•­ëª©ì„ 1-10ì ìœ¼ë¡œ í‰ê°€):
1. ê°€ë…ì„± (Readability)
2. ìœ ì§€ë³´ìˆ˜ì„± (Maintainability)  
3. ì„±ëŠ¥ (Performance)
4. ë³´ì•ˆ (Security)
5. í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± (Testability)
6. ì¬ì‚¬ìš©ì„± (Reusability)

JSON í˜•ì‹ìœ¼ë¡œ ê²°ê³¼ë¥¼ ë°˜í™˜í•´ì£¼ì„¸ìš”:
```
{{
  "overall_score": 0,
  "scores": {{
    "readability": 0,
    "maintainability": 0,
    "performance": 0,
    "security": 0,
    "testability": 0,
    "reusability": 0
  }},
  "strengths": ["ê°•ì 1", "ê°•ì 2"],
  "weaknesses": ["ì•½ì 1", "ì•½ì 2"],
  "recommendations": ["ê°œì„ ì‚¬í•­1", "ê°œì„ ì‚¬í•­2"]
}}
```
"""
        
        response = self.llm.predict(quality_prompt)
        
        try:
            import json
            quality_data = json.loads(response.strip())
            return quality_data
        except:
            return {"error": "ë¶„ì„ ê²°ê³¼ë¥¼ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤", "raw_response": response}
    
    def generate_tests(self, code: str, language: str = "python") -> str:
        """ì½”ë“œì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ìƒì„±"""
        
        test_prompt = f"""
ë‹¤ìŒ {language} ì½”ë“œì— ëŒ€í•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”:

```
{code}
```

í…ŒìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­:
- ì •ìƒ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸
- ê²½ê³„ê°’ í…ŒìŠ¤íŠ¸  
- ì˜ˆì™¸ ìƒí™© í…ŒìŠ¤íŠ¸
- {language}ì˜ í‘œì¤€ í…ŒìŠ¤íŒ… í”„ë ˆì„ì›Œí¬ ì‚¬ìš©

í…ŒìŠ¤íŠ¸ ì½”ë“œ:
"""
        
        return self.llm.predict(test_prompt)

# ì‚¬ìš© ì˜ˆì‹œ
analyzer = CodeQualityAnalyzer(llm)

sample_function = """
def calculate_bmi(weight, height):
    if height <= 0:
        raise ValueError("Height must be positive")
    
    bmi = weight / (height ** 2)
    
    if bmi < 18.5:
        category = "Underweight"
    elif bmi < 25:
        category = "Normal"
    elif bmi < 30:
        category = "Overweight"
    else:
        category = "Obese"
    
    return round(bmi, 2), category
"""

quality_report = analyzer.analyze_quality(sample_function)
test_cases = analyzer.generate_tests(sample_function)

print(f"ì „ì²´ ì ìˆ˜: {quality_report.get('overall_score', 'N/A')}/10")
print(f"í…ŒìŠ¤íŠ¸ ì½”ë“œ:\n{test_cases}")
```

### ğŸ“ ì½”ë“œ ë¬¸ì„œí™” ìë™ ìƒì„±ê¸°

```python
class CodeDocumentationGenerator:
    def __init__(self, llm):
        self.llm = llm
    
    def generate_docstring(self, function_code: str, language: str = "python") -> str:
        """í•¨ìˆ˜ì— ëŒ€í•œ docstring ìƒì„±"""
        
        docstring_prompt = f"""
ë‹¤ìŒ {language} í•¨ìˆ˜ì— ëŒ€í•œ ìƒì„¸í•œ docstringì„ ìƒì„±í•´ì£¼ì„¸ìš”:

```
{function_code}
```

í¬í•¨í•  ë‚´ìš©:
- í•¨ìˆ˜ ëª©ì  ë° ê¸°ëŠ¥ ì„¤ëª…
- ë§¤ê°œë³€ìˆ˜ ì„¤ëª… (íƒ€ì… í¬í•¨)
- ë°˜í™˜ê°’ ì„¤ëª… (íƒ€ì… í¬í•¨)
- ì˜ˆì™¸ ì²˜ë¦¬ ì •ë³´
- ì‚¬ìš© ì˜ˆì‹œ
- {language} í‘œì¤€ docstring í˜•ì‹ ì¤€ìˆ˜

Docstring:
"""
        return self.llm.predict(docstring_prompt)
    
    def generate_readme(self, project_code: str, project_name: str) -> str:
        """í”„ë¡œì íŠ¸ README ìƒì„±"""
        
        readme_prompt = f"""
ë‹¤ìŒ ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ í”„ë¡œì íŠ¸ "{project_name}"ì˜ README.md íŒŒì¼ì„ ìƒì„±í•´ì£¼ì„¸ìš”:

```
{project_code}
```

READMEì— í¬í•¨í•  ë‚´ìš©:
- í”„ë¡œì íŠ¸ ê°œìš”
- ì£¼ìš” ê¸°ëŠ¥
- ì„¤ì¹˜ ë°©ë²•
- ì‚¬ìš©ë²• (ì˜ˆì‹œ í¬í•¨)
- API ë¬¸ì„œ (í•´ë‹¹í•˜ëŠ” ê²½ìš°)
- ê¸°ì—¬ ë°©ë²•
- ë¼ì´ì„ ìŠ¤ ì •ë³´

Markdown í˜•ì‹ì˜ README:
"""
        return self.llm.predict(readme_prompt)

# ì‚¬ìš© ì˜ˆì‹œ
doc_generator = CodeDocumentationGenerator(llm)

function_code = """
def merge_sorted_arrays(arr1, arr2):
    result = []
    i, j = 0, 0
    
    while i < len(arr1) and j < len(arr2):
        if arr1[i] <= arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1
    
    result.extend(arr1[i:])
    result.extend(arr2[j:])
    
    return result
"""

docstring = doc_generator.generate_docstring(function_code)
print(docstring)
```

### ğŸ¯ ì–¸ì–´ë³„ ìµœì  ì„¤ì • ê°€ì´ë“œ

| ì–¸ì–´       | Temperature | Max Tokens | íŠ¹ë³„ ê³ ë ¤ì‚¬í•­             |
|------------|-------------|------------|--------------------------|
| Python     | 0.1-0.2     | 1024-2048  | PEP8 ì¤€ìˆ˜, íƒ€ì… íŒíŠ¸      |
| JavaScript | 0.1-0.3     | 1024-2048  | ES6+ ë¬¸ë²•, ëª¨ë“ˆí™”         |
| Java       | 0.1         | 2048-4096  | ê°ì²´ì§€í–¥ ì›ì¹™, ì˜ˆì™¸ ì²˜ë¦¬  |
| Bash       | 0.1         | 512-1024   | ì˜¤ë¥˜ ì²˜ë¦¬, ê°€ë…ì„±         |
| SQL        | 0.1         | 1024       | ì„±ëŠ¥ ìµœì í™”, ë³´ì•ˆ         |
| HTML/CSS   | 0.2-0.4     | 1024-2048  | ì ‘ê·¼ì„±, ë°˜ì‘í˜• ë””ìì¸     |

### âš ï¸ ì½”ë“œ í”„ë¡¬í”„íŒ… ì£¼ì˜ì‚¬í•­

```python
class CodePromptingBestPractices:
    """ì½”ë“œ í”„ë¡¬í”„íŒ… ëª¨ë²” ì‚¬ë¡€"""

    @staticmethod
    def validate_generated_code(code: str, language: str) -> dict:
        """ìƒì„±ëœ ì½”ë“œ ê²€ì¦"""
        warnings = []

        # ê¸°ë³¸ ê²€ì¦ í•­ëª©ë“¤
        if "TODO" in code or "FIXME" in code:
            warnings.append("ë¯¸ì™„ì„± ì½”ë“œê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤")

        if language == "python":
            if "input()" in code and "try:" not in code:
                warnings.append("ì‚¬ìš©ì ì…ë ¥ì— ëŒ€í•œ ì˜ˆì™¸ ì²˜ë¦¬ê°€ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤")

            if "import os" in code and "path.exists" not in code:
                warnings.append("íŒŒì¼/ë””ë ‰í„°ë¦¬ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ì„ ê³ ë ¤í•˜ì„¸ìš”")

        return {
            "is_safe": len(warnings) == 0,
            "warnings": warnings,
            "recommendations": [
                "ìƒì„±ëœ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê¸° ì „ì— ë°˜ë“œì‹œ ê²€í† í•˜ì„¸ìš”",
                "í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œ ë¨¼ì € í™•ì¸í•˜ì„¸ìš”",
                "ë³´ì•ˆ ì·¨ì•½ì ì„ ì²´í¬í•˜ì„¸ìš”"
            ]
        }

    @staticmethod
    def create_safe_prompt(task: str, language: str) -> str:
        """ì•ˆì „í•œ ì½”ë“œ ìƒì„± í”„ë¡¬í”„íŠ¸ ì‘ì„±"""

        safety_instructions = '''
ë‹¤ìŒ ë³´ì•ˆ ë° í’ˆì§ˆ ê¸°ì¤€ì„ ì¤€ìˆ˜í•´ì£¼ì„¸ìš”:
- ì…ë ¥ ê²€ì¦ í¬í•¨
- ì ì ˆí•œ ì˜¤ë¥˜ ì²˜ë¦¬
- ë³´ì•ˆ ì·¨ì•½ì  ë°©ì§€
- ì½”ë“œ ì£¼ì„ í¬í•¨
- í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ êµ¬ì¡°
'''

        return f"""{safety_instructions}

ì‘ì—…: {task}
ì–¸ì–´: {language}

ìš”êµ¬ì‚¬í•­ì„ ì¶©ì¡±í•˜ëŠ” ì•ˆì „í•˜ê³  í’ˆì§ˆ ë†’ì€ ì½”ë“œë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”:
"""

# ì‚¬ìš© ì˜ˆì‹œ
best_practices = CodePromptingBestPractices()

# ì•ˆì „í•œ í”„ë¡¬í”„íŠ¸ ìƒì„±
safe_prompt = best_practices.create_safe_prompt(
    "íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬ í•¨ìˆ˜",
    "python"
)

# ìƒì„±ëœ ì½”ë“œ ê²€ì¦
sample_code = '''
def upload_file(filename):
    with open(filename, 'r') as f:
        return f.read()
'''

validation = best_practices.validate_generated_code(sample_code, "python")
print(f"ì•ˆì „ì„± ê²€ì‚¬: {'í†µê³¼' if validation['is_safe'] else 'ì£¼ì˜ í•„ìš”'}")
if validation['warnings']:
    print("ê²½ê³ ì‚¬í•­:", validation['warnings'])
```

### ğŸ”„ ì§€ì†ì  ê°œì„  ë° í•™ìŠµ

```python
from datetime import datetime

class CodePromptLearner:
    def __init__(self):
        self.prompt_history = []
        self.success_patterns = []

    def log_prompt_result(self, prompt: str, generated_code: str,
                         success: bool, feedback: str = ""):
        """í”„ë¡¬í”„íŠ¸ ê²°ê³¼ ë¡œê¹…"""

        self.prompt_history.append({
            'prompt': prompt,
            'generated_code': generated_code,
            'success': success,
            'feedback': feedback,
            'timestamp': datetime.now()
        })

        if success:
            self.success_patterns.append({
                'prompt_structure': self._analyze_prompt_structure(prompt),
                'code_quality': self._analyze_code_quality(generated_code)
            })

    def get_best_practices_summary(self) -> dict:
        """ì„±ê³µ íŒ¨í„´ ë¶„ì„ ìš”ì•½"""
        if not self.success_patterns:
            return {"message": "ì¶©ë¶„í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤"}

        return {
            "ì´ ì‹œë„": len(self.prompt_history),
            "ì„±ê³µë¥ ": sum(1 for h in self.prompt_history if h['success']) / len(self.prompt_history),
            "ê°œì„  ê¶Œì¥ì‚¬í•­": self._generate_recommendations()
        }

    def _analyze_prompt_structure(self, prompt: str) -> dict:
        """í”„ë¡¬í”„íŠ¸ êµ¬ì¡° ë¶„ì„"""
        return {
            "has_examples": "ì˜ˆì‹œ" in prompt or "example" in prompt.lower(),
            "has_requirements": "ìš”êµ¬ì‚¬í•­" in prompt or "requirements" in prompt.lower(),
            "has_constraints": "ì œì•½" in prompt or "constraint" in prompt.lower(),
            "length": len(prompt)
        }

    def _analyze_code_quality(self, code: str) -> dict:
        """ì½”ë“œ í’ˆì§ˆ ë¶„ì„"""
        return {
            "has_comments": "#" in code or "//" in code or "\"\"\"" in code,
            "has_error_handling": "try" in code or "except" in code or "catch" in code,
            "length": len(code),
            "function_count": code.count("def ") + code.count("function ")
        }

    def _generate_recommendations(self) -> list:
        """ê°œì„  ê¶Œì¥ì‚¬í•­ ìƒì„±"""
        return [
            "êµ¬ì²´ì ì¸ ìš”êµ¬ì‚¬í•­ì„ í¬í•¨í•˜ì„¸ìš”",
            "ì˜ˆì‹œë¥¼ ì œê³µí•˜ë©´ ë” ì¢‹ì€ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤",
            "ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ìš”ì²­í•˜ì„¸ìš”",
            "ì½”ë“œ ì£¼ì„ì„ ìš”ì²­í•˜ì„¸ìš”"
        ]

# í•™ìŠµ ì‹œìŠ¤í…œ ì‚¬ìš©
learner = CodePromptLearner()

# í”„ë¡¬í”„íŠ¸ ê²°ê³¼ ê¸°ë¡
learner.log_prompt_result(
    prompt="Pythonìœ¼ë¡œ íŒŒì¼ì„ ì½ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ì£¼ì„¸ìš”",
    generated_code="def read_file(filename): return open(filename).read()",
    success=False,
    feedback="ì˜¤ë¥˜ ì²˜ë¦¬ê°€ ì—†ìŒ"
)

# ê°œì„ ëœ í”„ë¡¬í”„íŠ¸ ê²°ê³¼ ê¸°ë¡
learner.log_prompt_result(
    prompt="Pythonìœ¼ë¡œ íŒŒì¼ì„ ì•ˆì „í•˜ê²Œ ì½ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ì£¼ì„¸ìš”. ì˜¤ë¥˜ ì²˜ë¦¬ì™€ ì£¼ì„ì„ í¬í•¨í•´ì£¼ì„¸ìš”.",
    generated_code=\"\"\"
def read_file(filename):
    '''íŒŒì¼ì„ ì•ˆì „í•˜ê²Œ ì½ëŠ” í•¨ìˆ˜'''
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            return f.read()
    except FileNotFoundError:
        return None
    except Exception as e:
        print(f"ì˜¤ë¥˜ ë°œìƒ: {e}")
        return None
\"\"\",
    success=True,
    feedback="ì™„ë²½í•œ êµ¬í˜„"
)

summary = learner.get_best_practices_summary()
print(summary)
```

---

* ì¶œì²˜
    * [1] [Prompt Engineering from Google](https://www.kaggle.com/whitepaper-prompt-engineering)